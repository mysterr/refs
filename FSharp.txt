// Данный код представлен с разрешения автора, Скотта Влашина. Он был немного модифицирован.
// Для однострочных комментариев используется двойной слеш. 
(* 
    Многострочные комментарии можно сделать вот так (хотя обычно используют двойной слеш).
*)

// ======== "Переменные" (на самом деле нет) ==========
// Ключевое слово "let" определяет неизменяемое (иммутабельное) значение
let myInt = 5
let myFloat = 3.14
let myString = "привет"   // обратите внимание - указывать тип не нужно

// ======== Списки ============
let twoToFive = [ 2; 3; 4; 5 ]        // Списки создаются с помощью квадратных скобок,
                                      // для разделения значений используются точки с запятой.
let oneToFive = 1 :: twoToFive        // оператор :: создает список с новым первым элементом
// Результат: [1; 2; 3; 4; 5]

let zeroToFive = [0;1] @ twoToFive    // оператор @ объединяет два списка

// ВАЖНО: запятые никогда не используются для разделения значений, только точки с запятой!

// ======== Функции ========
// Ключевое слово "let" также определяет именованную функцию.
let square x = x * x          // Обратите внимание - скобки не используются.
square 3                      // А сейчас вызовем функцию. Снова никаких скобок.

let add x y = x + y           // не используйте add (x,y)! Это означает
                              // совершенно другую вещь.
add 2 3                       // Вызовем фукнкцию.

// чтобы определить многострочную функцию, просто используйте отступы.
// Точки с запятой не требуются.
let evens list =
   let isEven x = x % 2 = 0     // Определет "isEven" как внутреннюю ("вложенную") функцию
   List.filter isEven list      // List.filter - это библиотечная функция
                                // с двумя параметрами: предикат
                                // и список, которые требуется отфильтровать

evens oneToFive                 // Вызовем функцию

// Вы можете использовать скобки, чтобы уточнить приоритет.
// В данном примере, сначала используем "map" с двумя аргументами,
// а потом вызываем "sum" для результата.
// Без скобок "List.map" была бы передана как аргумент в "List.sum"
let sumOfSquaresTo100 =
   List.sum (List.map square [ 1 .. 100 ])

// Вы можете передать результат одной функции в следующую с помощью "|>"
// Вот та же самая функция sumOfSquares, переписанная с помощью конвейера
let sumOfSquaresTo100piped =
   [ 1 .. 100 ] |> List.map square |> List.sum  // "square" определена раньше

// вы можете определять лямбда-функции (анонимные функции) 
// с помощью ключевого слова "fun"
let sumOfSquaresTo100withFun =
   [ 1 .. 100 ] |> List.map (fun x -> x * x) |> List.sum

// В F# значения возвращаются неявно - ключевое слово "return" не используется
// Функция всегда возвращает значение последнего выражения в ее теле

// ======== Сопоставление с образцом ========
// Match..with.. - это case/switch инструкции "на стероидах".
let x = "a"
match x with
| "a" -> printfn "x - это a"
| "b" -> printfn "x - это b"
| _ -> printfn "x - это что-то другое"   // подчеркивание соответствует "чему угодно"

// Some(..) и None приблизительно соответствуют оберткам Nullable<T>
let validValue = Some(99)
let invalidValue = None

// В данном примере match..with сравнивает с "Some" и "None"
// и в то же время распаковывает значение в "Some".
let optionPatternMatch input =
   match input with
    | Some i -> printfn "целое число %d" i
    | None -> printfn "входное значение отсутствует"

optionPatternMatch validValue
optionPatternMatch invalidValue

// ========= Сложные типы данных =========

// Кортежи - это пары, тройки значений и так далее.
// Кортежи используют запятые.
let twoTuple = (1, 2)
let threeTuple = ("a", 2, true)

// Записи имеют именованные поля. Точки с запятой являются разделителями.
type Person = { First: string; Last: string }

let person1 = { First="John"; Last="Doe" }
// Вы можете также использовать переносы на новую строку
// вместо точек с запятой.
let person2 =
    { First="Jane"
      Last="Doe" }

// Объединения представляют варианты. Разделитель - вертикальная черта.
type Temp = 
    | DegreesC of float
    | DegreesF of float

let temp = DegreesF 98.6

// Типы можно комбинировать рекурсивно различными путями.
// Например, вот тип-объединение, который содержит список
// элементов того же типа:
type Employee = 
  | Worker of Person
  | Manager of Employee list

let jdoe = { First="John"; Last="Doe" }
let worker = Worker jdoe

// ========= Вывод на экран =========
// Функции printf/printfn схожи с функциями Console.Write/WriteLine из C#.
printfn "Вывод на экран значений типа int %i, float %f, bool %b" 1 2.0 true
printfn "Строка %s, и что-то обобщенное %A" "hello" [ 1; 2; 3; 4 ]

// все сложные типы имеют встроенный красивый вывод
printfn "twoTuple=%A,\nPerson=%A,\nTemp=%A,\nEmployee=%A" 
    twoTuple person1 temp worker